<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android项目使用美团的robust热修复方案 | 前端日常开发记录</title>

  

  
  <meta name="description" content="原理
Robust插件对每个产品代码的每个函数都在编译打包阶段自动的插入了一段代码，插入过程对业务开发是完全透明
编译打包阶段自动为每个class都增加了一个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 cha">
  

  
  
  <meta name="keywords" content="Android,hot fix">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Android项目使用美团的robust热修复方案"/>

  <meta property="og:site_name" content="前端日常开发记录"/>

  
  <meta property="og:image" content="/Blog/favicon.ico"/>
  

  <link href="/Blog/favicon.ico" rel="icon">
  <link rel="alternate" href="/Blog/atom.xml" title="前端日常开发记录" type="application/atom+xml">
  <link rel="stylesheet" href="/Blog/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/Blog/">前端日常开发记录</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Android项目使用美团的robust热修复方案</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Blog/2021/09/13/Android项目使用美团的robust热修复方案/" rel="bookmark">
        <time class="entry-date published" datetime="2021-09-13T15:46:25.000Z">
          2021-09-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>Robust插件对每个产品代码的每个函数都在编译打包阶段自动的插入了一段代码，插入过程对业务开发是完全透明</li>
<li>编译打包阶段自动为每个class都增加了一个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。</li>
</ul>
<h3 id="集成方法："><a href="#集成方法：" class="headerlink" title="集成方法："></a>集成方法：</h3><ul>
<li>在项目跟目录的build.gradle文件中引入robust，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classpath &#39;com.meituan.robust:gradle-plugin:0.4.99&#39;</span><br><span class="line">classpath &#39;com.meituan.robust:auto-patch-plugin:0.4.99&#39; </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<ul>
<li><p>在项目的app目录下的build.gradle文件中，加入如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.android.application&#39;</span><br><span class="line">&#x2F;&#x2F;制作补丁时将这个打开，auto-patch-plugin紧跟着com.android.application</span><br><span class="line">&#x2F;&#x2F;apply plugin: &#39;auto-patch-plugin&#39;</span><br><span class="line">apply plugin: &#39;robust&#39;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">compile &#39;com.meituan.robust:robust:0.4.99&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目的app目录下新建robust文件夹，后续打包时候有用。同时在该目录下面新建robust.xml文件，可以将美团github上面提供的demo里的文件拷到项目里面修改一下里面的配置。主要修改以下两个地方：</p>
</li>
</ul>
<p><img src="https://gj-prod-1256038144.cos.ap-beijing.myqcloud.com/common/1630981026918/2.png" alt="image.png"></p>
<ul>
<li>打开混淆，执行<code>gradle iR</code>,编译release包，这个时候打的是基准包。<br>编译后将build产生的mapping文件，以及build/outputs/robust文件夹里的methodsMap.robust文件这两个拷贝至app目录下的robust文件夹中。</li>
</ul>
<p>打补丁文件，找到要修改bug的地方，修改bug。</p>
<ul>
<li>修改代码，在改动的方法上面添加@Modify注解,对于Lambda表达式请在修改的方法里面调用RobustModify.modify()方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Modify</span><br><span class="line">@Override</span><br><span class="line">protected void initData(Bundle bundle) &#123;</span><br><span class="line">    Logger.t(&quot;robust-test&#x3D;&#x3D;&#x3D;&quot;).d(setValue());</span><br><span class="line">    tvConversation.setText(setValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Add</span><br><span class="line">public String setValue()&#123;</span><br><span class="line">    return &quot;热修复文本🍄🍄🍄&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行下面的代码加载补丁包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (PermissionUtils.isGrantSDCardReadPermission(getContext()) &amp;&amp; hasPatch )&#123;</span><br><span class="line">            new PatchExecutor(getContext(), new PatchManipulateImp(), new RobustCallBackSample(getContext(),patchVersion)).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>打开<code>apply plugin: &#39;auto-patch-plugin&#39;</code>注释，执行打包命令。</li>
</ul>
<ul>
<li>执行完毕后，如图所示：<br><img src="https://gj-prod-1256038144.cos.ap-beijing.myqcloud.com/common/1630981068404/3.png" alt="8903f5f4fc68328ab74ec7a9f4690261.png"></li>
</ul>
<p>提示编译失败，这种情况正常，只要出现<code>auto patch end successfully</code>就代表打补丁文件正常。此时会在build/outputs/robust文件夹下面生成patch.jar的文件，在终端中，进入到该目录下面，执行命令：<code>adb push patch.jar /storage/emulated/0/robust/patch.jar</code>，将该文件拷贝到手机中，验证补丁包是否生效。</p>
<p>但是在实际使用中，所有的补丁包应该通过网络方式下发到用户app中，遗憾的是美团的这套热修复方案是不包括补丁下发后台的，这块利用公司的八卦炉应用更新平台，可以实现补丁包的下载安装和使用。</p>
<p>为了区分环境，创建了如下两个下载文件：<br><img src="https://gj-prod-1256038144.cos.ap-beijing.myqcloud.com/common/1630981228197/4.png" alt="3c9a64f7fefbdb13c22a1370f0001217.png"><br>分别对应测试包和正式包。</p>
<p>目前的加载补丁策略是如下的流程：<br>在APP应用启动后，会去拉取补丁数据接口，如果有数据更新，会返回类似下面的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">        &quot;upgrade&quot;: true,</span><br><span class="line">        &quot;forceUpgrade&quot;: false,</span><br><span class="line">        &quot;totalUpgrade&quot;: true,</span><br><span class="line">        &quot;downloadUrl&quot;: &quot;https:&#x2F;&#x2F;cstore-1256841541.cos.ap-beijing.myqcloud.com&#x2F;etfapp&#x2F;886bd86d-585d-48c2-9177-63c5a038d0e8&#x2F;patch_2970_1630053574150.jar&quot;,</span><br><span class="line">        &quot;upgradeMsg&quot;: &quot;最新版补丁包&quot;,</span><br><span class="line">        &quot;versionName&quot;: &quot;2970&quot;,</span><br><span class="line">        &quot;versionCode&quot;: 2970,</span><br><span class="line">        &quot;upgradeDate&quot;: &quot;2021-08-27&quot;,</span><br><span class="line">        &quot;appSize&quot;: &quot;0.0&quot;,</span><br><span class="line">        &quot;MD5&quot;: &quot;A821FE76D540C995AA335DCEE2C6D392&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;code&quot;: 1,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果提示没有补丁包数据，不做处理，如果有补丁包数据，则把数据拷贝到指定目录，并调用加载补丁的方法，同时存储本次的补丁版本号，待下次请求补丁包数据时做版本对比。<br>由于执行生成补丁的插件打出的补丁文件都是patch.jar的文件，这块利用的八卦炉的升级策略，如果当前版本没有bug需要修复的时候，补丁文件的版本号同APP的版本号versioncode一致，当有bug需要修复时，假如当前系统版本号为<code>v2.9.7</code>，对应的versioncode是:2970,执行打补丁命令生成补丁文件，需要将其命名为<code>patch_2971.jar</code>，并上传至八卦炉平台并设为下载版本，如图所示：<img src="https://gj-prod-1256038144.cos.ap-beijing.myqcloud.com/common/1630981274908/5.png" alt="fbc1ef32569265b373fb89cb3c636d42.png"></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li><p>内部类的构造方法是private（private会生成一个匿名的构造函数）时，需要在制作补丁过程中手动修改构造方法的访问域为public</p>
</li>
<li><p>对于方法的返回值是this的情况现在支持不好，比如builder模式，但在制作补丁代码时，可以通过如下方式来解决，增加一个类来包装一下(如下面的B类)，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method a()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method a()&#123;</span><br><span class="line">  return new B().setThis(this).getThis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段增加能力内测中，不过暂时可以通过增加新类，把字段放到新类中的方式来实现字段增加能力</p>
</li>
<li><p>新增的类支持包括静态内部类和非内部类</p>
</li>
<li><p>对于只有字段访问的函数无法直接修复，可通过调用处间接修复</p>
</li>
<li><p>构造方法的修复内测中</p>
</li>
<li><p>资源和so的修复内测中</p>
</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>几乎不会影响性能（方法调用，冷启动）</li>
<li>支持Android2.3-8.x版本</li>
<li>高兼容性（Robust只是在正常的使用DexClassLoader）、高稳定性，修复成功率高达99.9%</li>
<li>补丁实时生效，不需要重新启动</li>
<li>支持方法级别的修复，包括静态方法</li>
<li>支持增加方法和类</li>
<li>支持ProGuard的混淆、内联、优化等操作</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>代码是侵入式的，会在原有的类中加入相关代码</li>
<li>so和资源的替换暂时不支持</li>
<li>会增大apk的体积，平均一个函数会比原来增加17.47个字节，10万个函数会增加1.67M。</li>
<li>会增加少量方法数，使用了Robust插件后，原来能被ProGuard内联的函数不能被内联了</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>另外经过测试，加固后的正式包，也是不影响bug修复的。</p>
<p>总体而言，如果不考虑增大apk的体积的话，只是简单的修复代码，不用修复so和资源，那么选择Robust是最稳定的。如果需要更全的功能，如so、资源更新等，那么目前来说选择Tinker是一个不错的方案。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/popfisher/p/8543973.html">https://www.cnblogs.com/popfisher/p/8543973.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Blog/categories/移动端开发/">移动端开发</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Blog/tags/Android/">Android</a><a href="/Blog/tags/hot-fix/">hot fix</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 前端日常开发记录
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>